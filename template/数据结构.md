## 树状数组

```cpp
template <typename T>
struct Fenwick {
    int n;
    std::vector<T> a;
    Fenwick(int n_ = 0) {
        init(n_);
    }
    void init(int n_) {
        n = n_;
        a.assign(n, T{});
    }
    void add(int i, const T &v) {
        while(i<n) {
            a[i]+=v;
            i+=i&-i;
        }
    }
    T get(int i) {
        T ans{};
        while(i>0){
            ans+=a[i];
            i-=i&-i;
        }
        return ans;
    }
    T range(int l, int r) {
        return get(r)-get(l-1);
    }
    int selectKth(const T &k) {
        int x = 0;
        T cur{};
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && cur + a[x + i - 1] <= k) {
                x += i;
                cur = cur + a[x - 1];
            }
        }
        return x;
    }
};
```

## 对顶堆

这里维护第k大(维护第k小对元素取负即可)
- 建立一大一小两个堆
- 记住小维护大,大维护小
- 小根堆用于维护值前k大的元素
- 大根堆用于维护值小于k大的元素
- 维护,一个堆超大小了就取出来丢到另外一个堆即可
- 插入的话,小于小根堆堆顶的元素就丢到大根堆,否则相反,然后维护
- 记得python中大根堆都是相反数
- 记得每次插入完都要update一下,有些题目会改变k,所以就不写死了insert后调用update

## 反悔堆

要最小化决策数量,一种决策代价低但是效果差(1-10效果,同种之间值不定),一种决策代价高但是效果好(100-200效果),我们先贪心的选代价低的决策,然后当不行的时候反悔最小的效果的决策并改为高代价的决策

[题目](https://leetcode.cn/problems/minimum-number-of-refueling-stops/description/)

```cpp
class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        vector<int> end(2);
        end[0]=target;
        end[1]=0;
        stations.push_back(end);
        sort(stations.begin(),stations.end());
        priority_queue<int> q;
        int cnt=0;
        int now=0;
        for(auto s:stations){
            int pos=s[0],fuel=s[1];
            if(pos>target)break;
            int d=pos-now;
            while(!q.empty()&&startFuel<d){
                startFuel+=q.top();
                q.pop();
                cnt++;
            }
            if(startFuel<d)return -1;
            startFuel-=d;
            now=pos;
            q.push(fuel);
        }
        return cnt;
    }
};
```

